# Описание проекта

Средство для шифрования, дешифрования и стеганографии на Python. Приложение предоставляет пользователю возможность выбора различных методов шифрования и стеганографии.


## Основной функционал

- **Шифрование и дешифрование файлов:**
  - На основе библиотеки NumPy
  - Поддержка шифрования файлов шифрами Цезаря, Виженера и Вернама.
  - Возможность выбора метода шифрования и передача ключа шифрования/дешифрования через аргументы командной строки.
  - Реализация функций шифрования и дешифрования по ключу.

- **Автоматический взлом шифра Цезаря:**
  - Применение методов частотного анализа для автоматического взлома шифра Цезаря.
  - Возможность дешифрования текста, зашифрованного шифром Цезаря без ключа.

- **Консольный интерфейс:**
  - Интерфейс с выбором методов шифрования, дешифрования по ключу, взлома без ключа.
  
- **Стеганография:**
  - На основе библиотеки Pillow.
  - Внедрение и извлечение текста из изображений формата JPG или PNG.
  - Использование последнего бита (или последних нескольких бит) каждого байта пикселя для скрытия информации.
  - Реализация функций для работы с изображениями и стеганографическими методами.

## Дополнительный функционал (будет реализовываться в порядке сверху-вниз).

- **Реализация услосложненных алгоритмов шифрования:**
  - Поддержка других алгоритмов шифрования, например, AES, RSA, SHA-256.

- **Визуализция частотности символов**
  - На основе библиотеки Matplotlib.
  - Возуализация графиков при анализе частотности символов при взломе шифра Цезаря.
  
- **Графический интерфейс:**
  - На основе библиотеки PyQt.
  - Пользовательский интерфейс с выбором методов шифрования, дешифрования и стеганографии, а также файлов для обработки.
  
## Архитектура

- **В приложенной Class Diagram**

## После реализации

- **Основной функционал**
  - Реализовано всё в полной мере (по ТЗ, про стеганографию *читать далее*).
  - Все методы шифруют по всему Юникоду (так безопаснее, но можно легко передалть на только английский).
  - Шифр Цезаря может определять язык сообщения, и выбирать шифровку по всему Юникоду или только по английскому алфавиту (Зашифрованные по англ. алфавиту взламываются методом частотного анализа).
  - NumPy не понадобился.
 
- **Дополнительный функционал**
  - Стеганография реализована на основе библиотеке Stegano, но технически, я не соврал, что на основе библиотеки Pillow, т.к. Stegano на основе Pillow.
  - Источник: https://git.sr.ht/~cedric/stegano/tree/master
  - Визуализация частотности символов реализована для английского алфавита.
  - По желанию пользователя, визуализируется как частота символов в шифре, так и стандартном алфавите.
  
- **Поправки в архитектуре**
  - Абстрактный класс Cipher был удалён за ненужностью, т.к. метод read_file больше свойственен класс UI, а больше в нём наследовать нечего
  - Классы для стеганографии были вырождены в один класс в силу работы с библиотекой Stegano
  
- **Использование**
  - Реализован частичный консольный и полностью интерактивный интерфейс
  - При вызове *python main.py* без аргументов автоматически вызывается интеративный режим
  - При вызове *python main.py -i* также вызовется интерактивный режим
  - Для консольного интерфейся синтаксис следующий: *usage: main.py [-h] [-i] {encrypt,decrypt,break,stego} [--cipher {caesar,vigenere,vernam}]*
  - При чтении текста или изображения из файла путь указывается относительно или абсолютно *./input.txt* для папок или файлов которые находятся вместе с исполняемым файлом
  - Чтобы указать путь на один слой вложенности меньше используется, например, *../data/input.txt*
  - Можно просто *"input.txt"*, если он лежит вместе с *main.py*
 
- **Послесловие**
  - Т.к. я не догадался найти частоту использования букв в интернете, я написал функцию которая это делает, так что *Tartt_Donna_The_Goldfinch.txt* удалять нельзя
  - Также, это значит, что вы можете загрузить свой текст и "обучить" FrequencyAnalyzer, но не обещаю, что это будет работать (правда нужно будет назвать его Tartt_Donna_The_Goldfinch.txt)
  - Некоторые методы не были включены в интерфейс, но есть в реализации, но я хочу о них рассказать: 
	 1. get_all_possible в CaesarBypass возвращает массив всех возможных слов, для каждого смещения
	 2. save_frequency сохраняет все частоты красивенько в файл по указанному пути из мапы, а load_frequency из подобных файлов, наоборот, выгружать в мапу(dict).	
  - Они нужны были мне для дебага, но я их оставил, потому что они прикольные.